<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expandable Program List</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="pc" id="program1a">
        <div class="pt">Program 1a</div>
        <div class="p_code">
           
            <pre><code>#https://www.onlinegdb.com/online_bash_shell
                #use the above link to run shell srcipt 
                
                #!/bin/bash
                
                #read the number 
                echo "Enter a number: "
                read number
                
                # Reverse the number 
                reversed=$(echo "$number" | rev)
                
                # Check it is palindrome or not
                if [ "$number" -eq "$reversed" ]; then
                    echo "$number is a palindrome."
                else
                    echo "$number is not a palindrome."
                fi</code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>
    <div class="pc" id="program1b">
        <div class="pt">Program 1b</div>
        <div class="p_code">
           
            <pre><code>#include <stdio.h>
                #include <limits.h>
                
                typedef struct
                {
                  int id;
                  int at;  // Arrival Time
                  int bt;  // Burst Time
                  int rt;  // Remaining Time
                  int ct;  // Completion Time
                  int tat; // Turnaround Time
                  int wt;  // Waiting Time
                } process; //  processess
                
                void calculateTimes(process processs[], int n)
                
                {
                  int curr_time = 0, completed = 0;
                  int min_rt, shortest = 0, finish_time;
                  int total_tat = 0, total_wt = 0;
                  printf("the gantt chart\n");
                
                  // to execute untill all the programs completed
                  while (completed != n)
                  {
                    // to find shortest processess
                    min_rt = INT_MAX;
                    for (int i = 0; i < n; i++)
                    {
                      if (processs[i].at <= curr_time && processs[i].rt < min_rt && processs[i].rt > 0)
                      {
                        min_rt = processs[i].rt; // instead of burst time we should use remaining as its a preemptive
                        shortest = i;
                      }
                    }
                
                    // if no precess arrived just move
                    if (min_rt == INT_MAX)
                    {
                      curr_time++;
                      continue;
                    }
                     printf("P%d\t",processs[shortest].id);
                    // one second of execution
                    processs[shortest].rt--;
                    curr_time++;
                
                    if (processs[shortest].rt == 0)
                    {
                      completed++;
                      finish_time = curr_time;
                      processs[shortest].ct = finish_time;
                      processs[shortest].tat = finish_time - processs[shortest].at;
                      processs[shortest].wt = processs[shortest].tat - processs[shortest].bt;
                
                      total_tat += processs[shortest].tat;
                      total_wt += processs[shortest].wt;
                    }
                  }
                
                  printf("\nprocess\tArrival\tBurst\tComp\tTurnaround\tWaiting\n");
                  for (int i = 0; i < n; i++)
                  {
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n", processs[i].id,
                           processs[i].at, processs[i].bt,
                           processs[i].ct, processs[i].tat,
                           processs[i].wt);
                  }
                  printf("\nAverage Turnaround Time: %.2f\n", (float)total_tat / n);
                  printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
                }
                
                int main()
                {
                  int n;
                
                  printf("Enter the number of processesses: ");
                  scanf("%d", &n);
                
                  process processs[n];
                  printf("Enter the arrival and burst time for each processess:\n");
                  for (int i = 0; i < n; i++)
                  {
                    processs[i].id = i + 1;
                    printf("processess P%d:\n", processs[i].id);
                    printf("Arrival time: ");
                    scanf("%d", &processs[i].at);
                    printf("Burst time: ");
                    scanf("%d", &processs[i].bt);
                    processs[i].rt = processs[i].bt; // here  iam using remaining time
                  }
                
                  calculateTimes(processs, n);
                
                  return 0;
                }
                </code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>

    <div class="pc" id="program2a">
        <div class="pt">Program 2a</div>
        <div class="p_code">
            
            <pre><code>#!/bin/bash
                # Program to generate the prime numbers of a given range
                echo "Enter the lower bound: "
                read n1
                echo "Enter the upper bound: "
                read n2
                for ((i=n1; i<=n2; i++))
                do
                for ((j=2; j<$i/2; j++))
                do
                if [[ $((i%j)) == 0 ]]
                then
                flag=1
                break
                fi
                done
                if [[ $flag == 0 ]]
                then
                echo -ne "$i " #This prints the numbers in a single line
                fi
                flag=0
                done</code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>
    <div class="pc" id="program2b">
        <div class="pt">Program 2b</div>
        <div class="p_code">
           
            <pre><code>#include <stdio.h>
                #include <limits.h>
                
                
                typedef struct {
                    int id;
                    int at;  // Arrival Time
                    int bt;  // Burst Time
                    int pri; // Priority
                    int rt;  // Remaining Time
                    int ct;  // Completion Time
                    int tat; // Turnaround Time
                    int wt;  // Waiting Time
                } Process;
                
                
                void calculateTimes(Process p[], int n) {
                    int curr_time = 0, completed = 0;
                    int total_tat = 0, total_wt = 0;
                    int prev_high_idx = -1;
                
                    printf("The Gantt chart\n");
                
                    while (completed != n) {
                        int high_idx = -1;
                        int high_pri = INT_MAX;
                
                        // Find the process with the highest priority that has arrived
                        for (int i = 0; i < n; i++) {
                            if (p[i].at <= curr_time && p[i].rt > 0) {
                                if (p[i].pri < high_pri || (p[i].pri == high_pri && p[i].at < p[high_idx].at)) {
                                    high_pri = p[i].pri;
                                    high_idx = i;
                                }
                            }
                        }
                
                       //here iam checking whether process changed or not , if it changed then only i print it
                        // if (prev_high_idx != high_idx && high_idx != -1) {
                        //     printf("P%d ", p[high_idx].id);
                        //     prev_high_idx = high_idx;
                        // }
                        
                         
                
                        // no process is arrived 
                        if (high_idx == -1) {
                            curr_time++;
                            continue;
                        }
                        printf("P%d ", p[high_idx].id);
                
                       
                        p[high_idx].rt--;
                        curr_time++;
                
                        
                        if (p[high_idx].rt == 0) {
                            completed++;
                            p[high_idx].ct = curr_time;
                            p[high_idx].tat = p[high_idx].ct - p[high_idx].at;
                            p[high_idx].wt = p[high_idx].tat - p[high_idx].bt;
                            total_tat += p[high_idx].tat;
                            total_wt += p[high_idx].wt;
                        }
                    }
                
                    // Print results
                    printf("\n\nProc\tArrival\tBurst\tPriority\tComp\tTurnaround\tWaiting\n");
                    for (int i = 0; i < n; i++) {
                        printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\n", p[i].id,
                               p[i].at, p[i].bt,
                               p[i].pri, p[i].ct,
                               p[i].tat, p[i].wt);
                    }
                    printf("\nAverage Turnaround Time: %.2f\n", (float)total_tat / n);
                    printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
                }
                
                int main() {
                    int n;
                
                    printf("Enter the number of processes: ");
                    scanf("%d", &n);
                
                    Process p[n];
                
                    for (int i = 0; i < n; i++) {
                        p[i].id = i + 1;
                        printf("Enter details of Process P%d:\n", p[i].id);
                        printf("Arrival time: ");
                        scanf("%d", &p[i].at);
                        printf("Burst time: ");
                        scanf("%d", &p[i].bt);
                        printf("Priority : ");
                        scanf("%d", &p[i].pri);
                        p[i].rt = p[i].bt; 
                    }
                
                    calculateTimes(p, n);
                
                    return 0;
                }
                </code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>

    <div class="pc" id="program3a">
        <div class="pt">Program 3a</div>
        <div class="p_code">
          <pre><code>#!/bin/bash
            echo "Enter the number of elements"
            read number
            numbers=()
            echo "Enter the numbers:"
            for ((i = 0; i < number; i++)); do
                read num
                numbers+=($num)
            done
            largest=${numbers[0]}
            for ((i = 1; i < number; i++)); do
                if [ "${numbers[i]}" -gt "$largest" ]; then
                    largest=${numbers[i]}
                fi
            done
            echo "The largest number is $largest"
            
        </code>
        </pre>
            <button class="copy-button">Copy</button>
        </div>
    </div>
    <div class="pc" id="program3b">
        <div class="pt">Program 3b</div>
        <div class="p_code">
            <pre><code>#include <stdio.h>
                #include <stdlib.h>
                
                typedef struct {
                    int id;         // Process ID
                    int arrival;    // Arrival Time
                    int burst;      // Burst Time
                    int completion; // Completion Time
                    int turnaround; // Turnaround Time
                    int waiting;    // Waiting Time
                    int inQueue;    // Flag 
                } Process;
                
                void swap(Process *a, Process *b) {
                    Process temp = *a;
                    *a = *b;
                    *b = temp;
                }
                
                void sortByArrival(int n, Process p[]) {
                    for (int i = 0; i < n - 1; i++) {
                        for (int j = 0; j < n - i - 1; j++) {
                            if (p[j].arrival > p[j + 1].arrival) {
                                swap(&p[j], &p[j + 1]);
                            }
                        }
                    }
                }
                
                int main() {
                    int n, total_waiting = 0, total_turnaround = 0, quantum;
                    float avg_waiting, avg_turnaround;
                    
                    printf("Enter the number of p: ");
                    scanf("%d", &n);
                    
                    Process p[n];
                    int original_burst[n]; 
                
                   
                    printf("Enter the arrival time and burst time of each process (AT BT):\n");
                    for (int i = 0; i < n; i++) {
                        p[i].id = i + 1;
                        printf("Process P%d: ", p[i].id);
                        scanf("%d %d", &p[i].arrival, &p[i].burst);
                        original_burst[i] = p[i].burst;
                        p[i].inQueue = 0; // Initialize flag
                    }
                
                    printf("Enter the time quantum: ");
                    scanf("%d", &quantum);
                
                    sortByArrival(n, p); //sorting
                
                    int completed = 0, currentTime = p[0].arrival;
                    int front = 0, rear = 0;
                    int *queue = (int *)malloc(n * sizeof(int));
                    queue[rear] = 0;
                    p[0].inQueue = 1;
                
                    
                    while (completed != n) {
                        int currentIdx = queue[front];
                        front = (front + 1) % n;
                
                        
                        if (p[currentIdx].burst > quantum) {
                            currentTime += quantum;
                            p[currentIdx].burst -= quantum;
                            printf("| P%d(%d) %d", p[currentIdx].id, quantum, currentTime);
                        } else {
                            currentTime += p[currentIdx].burst;
                            printf("| P%d(%d) %d", p[currentIdx].id, p[currentIdx].burst, currentTime);
                            p[currentIdx].burst = 0;
                            p[currentIdx].completion = currentTime;
                            p[currentIdx].turnaround = p[currentIdx].completion - p[currentIdx].arrival;
                            p[currentIdx].waiting = p[currentIdx].turnaround - original_burst[currentIdx];
                            total_turnaround += p[currentIdx].turnaround;
                            total_waiting += p[currentIdx].waiting;
                            completed++;
                        }
                
                     
                        for (int i = 0; i < n; i++) {
                            if (p[i].arrival <= currentTime && p[i].inQueue == 0 && p[i].burst > 0) {
                                rear = (rear + 1) % n;
                                queue[rear] = i;
                                p[i].inQueue = 1;
                            }
                        }
                
                       
                        if (p[currentIdx].burst > 0) {
                            rear = (rear + 1) % n;
                            queue[rear] = currentIdx;
                        }
                    }
                
                    // Calculate average times
                    avg_turnaround = (float)total_turnaround / n;
                    avg_waiting = (float)total_waiting / n;
                
                    // Print process details
                    printf("\n\nPID\tAT\tBT\tCT\tTAT\tWT\n");
                    for (int i = 0; i < n; i++) {
                        printf("%d\t%d\t%d\t%d\t%d\t%d\n", p[i].id, p[i].arrival, original_burst[i], p[i].completion, p[i].turnaround, p[i].waiting);
                    }
                    printf("\nAverage Turnaround Time = %.2f\nAverage Waiting Time = %.2f\n", avg_turnaround, avg_waiting);
                
                    free(queue);
                    return 0;
                }
                </code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>


    <div class="pc" id="program12a">
        <div class="pt">Program 4a</div>
        <div class="p_code">
    
            <pre><code>#                             Online Bash Shell.
                #      #                             Online Bash Shell.
                #                 Code, Compile, Run and Debug Bash script online.
                # Write your code in this editor and press "Run" button to execute it.
                
                #!/bin/bash
                
                echo "Enter the number of rows:"
                read rows
                echo "Enter the number of columns:"
                read cols
                
                echo "Enter elements of the first matrix:"
                for ((i = 0; i < rows; i++)); do
                    for ((j = 0; j < cols; j++)); do
                        read a[$((i * cols + j))]
                    done
                done
                
                echo "Enter elements of the second matrix:"
                for ((i = 0; i < rows; i++)); do
                    for ((j = 0; j < cols; j++)); do
                        read b[$((i * cols + j))]
                    done
                done
                
                echo "First Matrix:"
                for ((i = 0; i < rows; i++)); do
                    for ((j = 0; j < cols; j++)); do
                        echo -n "${a[$((i * cols + j))]} "
                    done
                    echo
                done
                
                echo "Second Matrix:"
                for ((i = 0; i < rows; i++)); do
                    for ((j = 0; j < cols; j++)); do
                        echo -n "${b[$((i * cols + j))]} "
                    done
                    echo
                done
                
                echo "RResult:"
                for ((i = 0; i < rows; i++)); do
                    for ((j = 0; j < cols; j++)); do
                        sum=$(( ${a[$((i * cols + j))]} + ${b[$((i * cols + j))]} ))
                        echo -n "$sum "
                    done
                    echo
                done
                
                
                
                </code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>
    <div class="pc" id="program4b">
        <div class="pt">Program 4b</div>
        <div class="p_code">
 
            <pre><code>#include <stdio.h>
                #include <limits.h>
                //(lower number indicates higher priority)
                typedef struct
                {
                  int id;
                  int at;  // Arrival Time
                  int bt;  // Burst Time
                  int pri; // Priority
                  int ct;  // Completion Time
                  int tat; // Turnaround Time
                  int wt;  // Waiting Time
                } Process;
                void calculateTimes(Process p[], int n)
                {
                  int curr_time = 0, completed = 0;
                  int total_tat = 0, total_wt = 0;
                    printf("the gantt chart\n");
                
                  while (completed != n)
                  {
                    int high_pri_idx = -1;
                    int high_pri = INT_MAX;
                
                    for (int i = 0; i < n; i++)
                    {
                      if (p[i].at <= curr_time && p[i].ct == 0)
                      {
                        if (p[i].pri < high_pri)
                        {
                          high_pri = p[i].pri;
                          high_pri_idx = i;
                        }
                      }
                    } printf("P%d\t",p[high_pri_idx].id);
                
                    // no process is arrived at that time
                    if (high_pri_idx == -1)
                    {
                      curr_time++;
                      continue;
                    }
                
                    curr_time += p[high_pri_idx].bt;
                    p[high_pri_idx].ct = curr_time;
                    p[high_pri_idx].tat = curr_time - p[high_pri_idx].at;
                    p[high_pri_idx].wt = p[high_pri_idx].tat - p[high_pri_idx].bt;
                
                    total_tat += p[high_pri_idx].tat;
                    total_wt += p[high_pri_idx].wt;
                    completed++;
                  }
                
                  printf("\nProc\tArrival\tBurst\tPriority\tComp\tTurnaround\tWaiting\n");
                  for (int i = 0; i < n; i++)
                  {
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\n", p[i].id,
                           p[i].at, p[i].bt,
                           p[i].pri, p[i].ct,
                           p[i].tat, p[i].wt);
                  }
                  printf("\nAverage Turnaround Time: %.2f\n", (float)total_tat / n);
                  printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
                }
                
                int main()
                {
                  int n;
                
                  printf("Enter the number of processes: ");
                  scanf("%d", &n);
                
                  Process p[n];
                 
                  for (int i = 0; i < n; i++)
                  {printf("Enter details of Process P%d:\n", p[i].id);
                    p[i].id = i + 1;
                    printf("Process P%d:\n", p[i].id);
                    printf("Arrival time: ");
                    scanf("%d", &p[i].at);
                    printf("Burst time: ");
                    scanf("%d", &p[i].bt);
                    printf("Priority : ");
                    scanf("%d", &p[i].pri);
                    p[i].ct = 0; // Iam using completion time
                  }
                
                  calculateTimes(p, n);
                
                  return 0;
                }
                </code></pre>
                <button class="copy-button">Copy</button>
        </div>
    </div>
    <div class="pc" id="program1a">
      <div class="pt">Program 5a</div>
      <div class="p_code">
         
          <pre><code>#include <stdio.h>
            #include <stdlib.h>
            #include <sys/types.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <unistd.h>
            #define BUFFER_SIZE 30
            int main()
            {
              int fd = open("example.txt", O_RDWR), n;
              char buffer[BUFFER_SIZE];
              printf("File discriptor is %d\n", fd);
              if (fd == -1)
              {
                printf("Failed to open file.\n");
                exit(0);
              }
              printf("Reading first 10 characters from file: \n");
              n = read(fd, buffer, 10);
              write(1, buffer, n);
              printf("\nSkipping 5 charecters from current position in the file: \n");
              lseek(fd, 5, SEEK_CUR);
              n = read(fd, buffer, 10);
              write(1, buffer, n);
              printf("\nGoing 10 charecters before the current position in the file: \n");
              lseek(fd, -10, SEEK_CUR);
              n = read(fd, buffer, 10);
              write(1, buffer, n);
              printf("\nGoing to 5th last charecter in the file: \n");
              lseek(fd, -5, SEEK_END);
              n = read(fd, buffer, 5);
              write(1, buffer, n);
              printf("\nGoing to the 3rd charecter in the file: \n");
              lseek(fd, 3, SEEK_SET);
              n = read(fd, buffer, 5);
              write(1, buffer, n);
              return 0;
            }
            </code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>
  <div class="pc" id="program1b">
      <div class="pt">Program 5b</div>
      <div class="p_code">
         
          <pre><code>#include <stdio.h>

            typedef struct {
                int id;
                int at; // Arrival Time
                int bt; // Burst Time
                int ct; // Completion Time
                int tat; // Turnaround Time
                int wt; // Waiting Time
            } Process;
            
            void sortProcessesByArrivalTime(Process p[], int n) {
                for (int i = 0; i < n - 1; i++) {
                    for (int j = 0; j < n - i - 1; j++) {
                        if (p[j].at > p[j + 1].at) {
                            // Swap processes
                            Process temp = p[j];
                            p[j] = p[j + 1];
                            p[j + 1] = temp;
                        }
                    }
                }
            }
            
            void calculateTimes(Process p[], int n) {
                int total_tat = 0, total_wt = 0;
                int time = 0;
            
                for (int i = 0; i < n; i++) {
                    if (time < p[i].at) {
                        time = p[i].at;
                    }
            
                    p[i].ct = time + p[i].bt;
                    p[i].tat = p[i].ct - p[i].at;
                    p[i].wt = p[i].tat - p[i].bt;
            
                    total_tat += p[i].tat;
                    total_wt += p[i].wt;
            
                    time = p[i].ct;
                }
            
                // Print results
                printf("\nProcess\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n", p[i].id, p[i].at, p[i].bt, p[i].ct, p[i].tat, p[i].wt);
                }
                printf("\nAverage Turnaround Time: %.2f\n", (float)total_tat / n);
                printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                Process p[n];
            
                for (int i = 0; i < n; i++) {
                    p[i].id = i + 1;
                    printf("Process P%d:\n", p[i].id);
                    printf("Arrival time: ");
                    scanf("%d", &p[i].at);
                    printf("Burst time: ");
                    scanf("%d", &p[i].bt);
                }
            
                sortProcessesByArrivalTime(p, n);
                calculateTimes(p, n);
            
                return 0;
            }
            </code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>

  <div class="pc" id="program2a">
      <div class="pt">Program 6a</div>
      <div class="p_code">
          
          <pre><code>/*program to inplement the zombie process*/
            #include<stdio.h>
            #include<stdlib.h>
            #include<sys/types.h>
            #include<unistd.h>
            int main() {
            pid_t my_pid, child_pid, parent_pid;
            child_pid = fork();
            if (child_pid < 0) {
            printf("\nFork failed, exiting!!\n");
            exit(1);
            }
            if (child_pid == 0) {
            // This is the child process part
            printf("\n[CHILD] This is the child process.\n");
            my_pid = getpid();
            parent_pid = getppid();
            printf("[CHILD] My pid is %d\n", my_pid);
            printf("[CHILD] My parent's pid is %d\n", parent_pid);
            printf("[CHILD] Exiting\n");
            exit(1);
            } else {
            // This is the parent process part
            printf("\n[PARENT] This is the parent process\n");
            my_pid = getpid();
            parent_pid = getppid();
            printf("[PARENT] My pid is %d\n", my_pid);
            printf("[PARENT] My parent's pid is %d\n", parent_pid);
            printf("[PARENT] Sleeping for 10 seconds\n");
            sleep(10);
            printf("\n[PARENT] Child process with pid = %d has ended, but still has an entry in theprocess table. \n", child_pid);
            printf("[PARENT] It is therefore a Zombie process\n");
            }
            return 0;
            }<br>#include<stdio.h>
                #include<stdlib.h>
                #include<unistd.h>
                #include<sys/types.h>
                int main() {
                pid_t my_pid, parent_pid, child_pid;
                child_pid = fork();
                if (child_pid < 0) {
                printf("\nFork failed, exiting!!\n");
                exit(1);
                }
                if (child_pid == 0) {
                // This is the child process
                printf("\n[CHILD] This is the child process.\n");
                my_pid = getpid();
                parent_pid = getppid();
                printf("[CHILD] My pid is %d\n", my_pid);
                printf("[CHILD] My parent's pid is %d\n", parent_pid);
                printf("[CHILD] Sleeping for 10 seconds\n");
                sleep(10);
                printf("\n[CHILD] My parent has ended, so I am an orphan process, adopted by init process\n");
                } else {
                // This is the parent process part
                printf("\n[PARENT] This is the parent process.\n");
                my_pid = getpid();
                parent_pid = getppid();
                printf("[PARENT] My pid is %d\n", my_pid);
                printf("[PARENT] My parent's pid is %d\n", parent_pid);
                printf("[PARENT] Exiting\n");
                exit(0);
                }
                return 0;
                }</code></pre>
                <button class="copy-button">Copy</button>
      </div>
  </div>
  <div class="pc" id="program2b">
      <div class="pt">Program 6b</div>
      <div class="p_code">
         
          <pre><code>#include <stdio.h>

            typedef struct {
                int id;
                int at; // Arrival Time
                int bt; // Burst Time
                int ct; // Completion Time
                int tat; // Turnaround Time
                int wt; // Waiting Time
                int completed; // Completion flag
            } Process; // Process
            
            void calculateTimes(Process p[], int n) {
                int time = 0, completed = 0;
                int total_tat = 0, total_wt = 0;
               printf("The Gantt chart\n");
                while (completed != n) {
                    int min_index = -1;
                    int min_bt = 100000; // A large number
            
                  
                    for (int i = 0; i < n; i++) {
                        if (p[i].at <= time && !p[i].completed) {
                            if (p[i].bt < min_bt) {
                                min_bt = p[i].bt;
                                min_index = i;
                            }
                        }
                    }
            
                    if (min_index == -1) {
                        
                        time++;
                    } else {
                       printf("P%d ", p[min_index].id);
                         time += p[min_index].bt;
                        p[min_index].ct = time;
                        p[min_index].tat = p[min_index].ct - p[min_index].at;
                        p[min_index].wt = p[min_index].tat - p[min_index].bt;
            
                        total_tat += p[min_index].tat;
                        total_wt += p[min_index].wt;
                        p[min_index].completed = 1;
                        completed++;
                    }
                }
            
                // Print results
                printf("\nProcess\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
                for (int i = 0; i < n; i++) {
                    printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n", p[i].id,
                           p[i].at, p[i].bt, p[i].ct, p[i].tat,
                           p[i].wt);
                }
                printf("\nAverage Turnaround Time: %.2f\n", (float)total_tat / n);
                printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
            }
            
            int main() {
                int n;
            
                printf("Enter the number of processes: ");
                scanf("%d", &n);
            
                Process p[n];
                printf("Enter the arrival time and burst time for each process:\n");
                for (int i = 0; i < n; i++) {
                    p[i].id = i + 1;
                    printf("Process P%d:\n", p[i].id);
                    printf("Arrival time: ");
                    scanf("%d", &p[i].at);
                    printf("Burst time: ");
                    scanf("%d", &p[i].bt);
                    p[i].completed = 0;
                }
            
                calculateTimes(p, n);
            
                return 0;
            }
            </code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>

  <div class="pc" id="program3a">
      <div class="pt">Program 7a</div>
      <div class="p_code">
        <pre><code>// Simulation of "grep" command
            #include<stdio.h>
            #include<string.h>
            void main()
            {
            char fn[10],pat[10],temp[200];
            FILE *fp;
            printf("Enter file name\n");
            scanf("%s",fn);
            printf("Enter pattern to be searched\n");
            scanf("%s",pat);
            fp=fopen(fn,"r");
            while(!feof(fp))
            {
            
            
            fgets(temp,100,fp);
            if(strstr(temp,pat))
            printf("%s",temp);
            }
            fclose(fp);
            }</code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>
  <div class="pc" id="program3b">
      <div class="pt">Program 7b</div>
      <div class="p_code">
          <pre><code>//child program 
            #include <sys/types.h>
            #include <sys/wait.h>
            #include <stdio.h>
            #include <string.h>
            #include <unistd.h>
            #include <sys/shm.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <sys/mman.h>
            #include<stdlib.h>
            int main(int argc,char *argv[])
            {
                     int k=2,n1,n2,n3;
                     void*ptr;
                     int shm_fd = shm_open("VSS", O_CREAT | O_RDWR, 0666);
                     ftruncate(shm_fd,4096);
                     ptr = mmap(0,4096,PROT_WRITE, MAP_SHARED, shm_fd, 0);
                     printf("CHILD:\n");
                     int i=atoi(argv[1]);
                     n1=0;
                     n2=1;
                     sprintf(ptr,"%d ",n1);
                     ptr+=strlen(ptr);
                     printf("%d ",n1);
                     sprintf(ptr,"%d ",n2);
                     ptr+=strlen(ptr);
                     printf("%d ",n2);
                     while (k!=i)
                     {
                            n3=n1+n2;
                            sprintf(ptr,"%d ", n3);
                            printf("%d ", n3);
                            n1=n2;
                            n2=n3;
                            ptr += strlen(ptr);
                            k++;
                }
            }
                
            <br>//parent.c
            #include <stdlib.h>
            #include <sys/types.h>
            #include <sys/wait.h>
            #include <stdio.h>
            #include <string.h>
            #include <unistd.h>
            #include <sys/shm.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <sys/mman.h>
            int main(int argc,char *argv[])
            {
                int i;
                pid_t pid;
                int k;
                int n1,n2,n3;
                const int SIZE = 4096;
                    int shm_fd;
                void *ptr;
                if (argc > 1)
                {
                    sscanf(argv[1], "%d", &i);
                    if (i < 1)
                    {
                        printf("Error input: %d\n", i);
                        return 0;
                    }
                }
                else
                {
                  printf("Error: not passing N in command line\n");
                  exit(0);
                }
                pid = fork();
                if (pid == 0)// CHILD
                {   
                    execlp("./fib","fib",argv[1],NULL);
                }
                else if (pid > 0)
                {
                    wait(NULL);
                    printf("\nPARENT: child completed\n");
            
                    shm_fd = shm_open("VSS", O_RDONLY, 0666);
                    ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
                    printf("Parent printing:\n");
                    printf("%s ", (char *)ptr);
                    shm_unlink("VSS");
                }
                return 0;
            }
            </code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>


  <div class="pc" id="program12a">
      <div class="pt">Program 8a</div>
      <div class="p_code">
  
          <pre><code>#include<stdio.h>
            #include<sys/types.h>
            #include<dirent.h>
            #include<stdlib.h>
            void main(int argc, char *argv[])
            {
            DIR *dp;
            struct dirent *dirp;
            if(argc<2)
            {
            printf("\n You are not passing the directory\n");
            exit(1);
            }
            if((dp=opendir(argv[1]))==NULL)
            {
            printf("\nCannot open it does't exist %s file!\n",argv[1]);
            exit(1);
            }
            while((dirp=readdir(dp))!=NULL)
            printf("%s\n",dirp->d_name);
            closedir(dp);
            }
            /*Save the above program as filename.c
            Create a directory with any 2 or more files
            Compile the .c (above program) file and then execute the file by passing the folder as the 2nd
            argument.
            Gcc filename.c
            Chmod 777 filename.c
            ./a.out foldername*/</code></pre>
            <button class="copy-button">Copy</button>
      </div>
  </div>
  <div class="pc" id="program12b">
      <div class="pt">Program 8b</div>
      <div class="p_code">

          <pre><code>// same as 7child and parent program</code></pre>
      </div>
  </div>
  <div class="pc" id="program1a">
    <div class="pt">Program 9a</div>
    <div class="p_code">
       
        <pre><code>#https://www.onlinegdb.com/online_bash_shell
            #use the above link to run shell srcipt 
            
            #!/bin/bash
            
            #read the number 
            echo "Enter a number: "
            read number
            
            # Reverse the number 
            reversed=$(echo "$number" | rev)
            
            # Check it is palindrome or not
            if [ "$number" -eq "$reversed" ]; then
                echo "$number is a palindrome."
            else
                echo "$number is not a palindrome."
            fi</code></pre>
            <button class="copy-button">Copy</button>
    </div>
</div>
<div class="pc" id="program1b">
    <div class="pt">Program 9b</div>
    <div class="p_code">
       
        <pre><code>//parent program
            #include <stdio.h>
            #include <sys/shm.h>
            #include <sys/ipc.h>
            #include <sys/types.h>
            #include <sys/wait.h>
            #include <unistd.h>
            
            typedef struct {
                int n;
                int arr[100];
            } pack_t;
            
            int main() {
                key_t key = 1234;
                int shmid = shmget(key, sizeof(pack_t), 0666 | IPC_CREAT);
                pack_t* shm_ptr = (pack_t*) shmat(shmid, NULL, 0666);
                printf("[PARENT] Created shared memory with key = %d, id = %d, address = %p\n", key, shmid, shm_ptr);
                printf("[PARENT] Enter n: ");
                scanf("%d", &shm_ptr->n);
                pid_t child_pid;
                if ((child_pid = fork()) == 0) {
                    execlp("./child", "./child", NULL); // Child
                } else {
                    wait(NULL);
                    printf("[PARENT] Child finished executing.\n");
                    printf("[PARENT] The first %d odd numbers are: \n", shm_ptr->n);
                    for (int i = 0; i < shm_ptr->n; i++)
                        printf("%d ", shm_ptr->arr[i]);
                    putchar('\n');
                }
            
                shmdt((void*) shm_ptr);
                shmctl(shmid, IPC_RMID, NULL); // Delete shared memory
                printf("[PARENT] Shared Memory Deleted\n");
                return 0;
            }
            <br>//child program
            #include <stdio.h>
            #include <sys/shm.h>
            #include <sys/ipc.h>
            #include <sys/types.h>
            
            typedef struct {
                int n;
                int arr[100];
            } pack_t;
            
            int main() {
                key_t key = 1234;
                int shmid = shmget(key, sizeof(pack_t), 0666);
                pack_t* shm_ptr = (pack_t*) shmat(shmid, NULL, 0666);
                printf("[CHILD] Attached to shared memory with key = %d, id = %d. address = %p\n", key, shmid, shm_ptr);
                for (int i = 0; i < shm_ptr->n; i++)
                    shm_ptr->arr[i] = 2*i + 1;
                printf("[CHILD] Finished generating first %d odd numbers\n", shm_ptr->n);
                shmdt((void*) shm_ptr);
                return 0;
            }
            
            </code></pre>
            <button class="copy-button">Copy</button>
    </div>
</div>

<div class="pc" id="program2a">
    <div class="pt">Program 10a</div>
    <div class="p_code">
        
        <pre><code>//simulate CAT cmd (VIEW only)
            #include <stdio.h>
                #include <stdlib.h>
                
                void main(int argc, char *argv[])
                {
                    FILE *fp;
                    char ch;
                
                    if (argc < 2)
                    {
                        printf("File not entered\n");
                        exit(1);
                    }
                
                    fp = fopen(argv[1], "r");
                    if (fp == NULL)
                    {
                        printf("File does not exist\n");
                        exit(1);
                    }
                
                    while ((ch = fgetc(fp)) != EOF)
                    {
                        printf("%c", ch);
                    }
                
                    fclose(fp);
                    printf("\n");
                }
                </code></pre>
                <button class="copy-button">Copy</button>

    </div>
</div>
<div class="pc" id="program2b">
    <div class="pt">Program 10b</div>
    <div class="p_code">
       
        <pre><code>//parent.c

            #include <stdio.h>
           #include <sys/types.h>
           #include <sys/wait.h>
           #include <stdio.h>
           #include <string.h>
           #include <unistd.h>
           #include <sys/shm.h>
           #include <sys/stat.h>
           #include <fcntl.h>
           #include <sys/mman.h>
           #include <stdlib.h>
            
           int main (int arguementCount, char *arguementVector[]) {
                       int i, k, n1, n2, sharedMemoryFileDescriptor, j;
                       const int SIZE = 4096;
                       pid_t processID;
                       void *ptr;
                       if (arguementCount > 2) {
                                   sscanf(arguementVector[1], "%d", &i);
                                   sscanf(arguementVector[2], "%d", &j);
                                   if (i < 2) {
                                               printf("Error input: %d\n", i);
                                               return 0;
                                   }
                       } else {
                                   printf("Error: Minimum of two arguements must be passed as command line arguements!");
                                   exit(0);
                       }
                       processID = fork();
                       if (processID == 0) {
                                   execlp("./child.c", "prime", arguementVector[1], arguementVector[2], NULL);
                       } else if (processID > 0) {
                                   wait(NULL);
                                   printf("\nParent: child complete!\n");
                                   sharedMemoryFileDescriptor = shm_open("OS", O_RDONLY, 0666);
                                   ptr = mmap(0, SIZE, PROT_READ, MAP_SHARED, sharedMemoryFileDescriptor, 0);
                                   printf("%s", (char *) ptr);
                                   shm_unlink("OS");
                       }
                       return 0;
           }
            
           
           //child.c
            #include <sys/types.h>
           #include <sys/wait.h>
           #include <stdio.h>
           #include <string.h>
           #include <unistd.h>
           #include <sys/shm.h>
           #include <sys/stat.h>
           #include <fcntl.h>
           #include <sys/mman.h>
           #include<stdlib.h>
           #include <math.h>
           int main(int arguementCount,char *arguementVector[]) {
                       void *ptr;
                       int sharedMemoryFileDescriptor = shm_open("VSS", O_CREAT | O_RDWR, 0666);
                       ftruncate(sharedMemoryFileDescriptor,4096);
                       ptr = mmap(0,4096,PROT_WRITE, MAP_SHARED, sharedMemoryFileDescriptor, 0);
                       printf("CHILD:\n");
                       int i = atoi(arguementVector[1]);
                       int j = atoi(arguementVector[2]);
                       int flag = 0;
                       printf("The prime numbers in the range %d and %d are:\n", i, j);
                       for (int num = i; num < j; num++) {
                           flag = 0;
                           for (int k = 2; k <= n/2; k++) {
                                    if (num % k == 0) {
                                        flag = 1;
                                        break;
                                    }
                           }
                           if (flag == 0) {
                                    printf("%d\t", num);
                           }
                       }                         	
                       printf("\n");
           }
           </code></pre>
           <button class="copy-button">Copy</button>
    </div>
</div>

<div class="pc" id="program3a">
    <div class="pt">Program 11a</div>
    <div class="p_code">
      <pre><code>
        //gcc thread.c -pthread -o thread
        #include<stdio.h>
        #include<stdlib.h>
        #include<pthread.h>
        int sm=0, prod=1;
        void *sum(void *parm)
        {
        int i, n;
        n = atoi(parm);
        printf("inside sum thread\n");
        
        for(i=1; i<=n;i++)
        {
        sm+=i;
        }
        printf("sum thread completed\n");
        }
        void *fact(void *parm)
        {
        int i, n;
        n = atoi(parm);
        printf("inside mul thread\n");
        for(i=2; i<=n;i++)
        {
        prod =prod *i;
        
        }
        printf("mul thread completed product\n");
        }
        void main(int argc, char * argv[])
        {
        pthread_t T1,T2;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_create(&T1, &attr, sum, argv[1]);
        pthread_create(&T2, &attr, fact, argv[1]);
        pthread_join(T1,NULL);
        pthread_join(T2,NULL);
        printf("Inside main thread\n");
        printf("sum=%d\n",sm);
        printf("product=%d\n",prod);
        }	 	 	 	
        </code></pre>
        <button class="copy-button">Copy</button>

    </div>
</div>
<div class="pc" id="program3b">
    <div class="pt">Program 11b</div>
    <div class="p_code">
        <pre><code>#include <pthread.h>
            #include <semaphore.h>
            #include <stdlib.h>
            #include <stdio.h>
            #define MaxItems 3 // Maximum items a producer can produce or a consumer can consume
            #define BufferSize 3 // Size of the buffer
            
            sem_t empty;
            sem_t full;
            int in = 0;
            int out = 0;
            int buffer[BufferSize];
            pthread_mutex_t mutex;
            
            void *producer(void *pno)
            {   
                int item;
                for(int i = 0; i < MaxItems; i++) {
                    item = rand()%100; // Produce an random item
                    sem_wait(&empty);
                    pthread_mutex_lock(&mutex);
                    buffer[in] = item;
                    printf("Producer %d: Insert Item %d at %d\n", *((int *)pno),buffer[in],in);
                    in = (in+1)%BufferSize;
                    pthread_mutex_unlock(&mutex);
                    sem_post(&full);
                }
            }
            void *consumer(void *cno)
            {   
                for(int i = 0; i < MaxItems; i++) {
                    sem_wait(&full);
                    pthread_mutex_lock(&mutex);
                    int item = buffer[out];
                    printf("Consumer %d: Remove Item %d from %d\n",*((int *)cno),item, out);
                    out = (out+1)%BufferSize;
                    pthread_mutex_unlock(&mutex);
                    sem_post(&empty);
                }
            }
            int main()
            {   
            
                pthread_t pro[3],con[3];
                pthread_mutex_init(&mutex, NULL);
                sem_init(&empty,0,BufferSize);
                sem_init(&full,0,0);
            
                int a[3] = {1,2,3}; //Just used for numbering the producer and consumer
            
                for(int i = 0; i < 3; i++) {
                    pthread_create(&pro[i], NULL, (void *)producer, (void *)&a[i]);
                }
                for(int i = 0; i < 3; i++) {
                    pthread_create(&con[i], NULL, (void *)consumer, (void *)&a[i]);
                }
            
                for(int i = 0; i < 3; i++) {
                    pthread_join(pro[i], NULL);
                }
                for(int i = 0; i < 3; i++) {
                    pthread_join(con[i], NULL);
                }
            
                pthread_mutex_destroy(&mutex);
                sem_destroy(&empty);
                sem_destroy(&full);
            
                return 0;
              }  
            
            </code></pre>
            <button class="copy-button">Copy</button>

    </div>
</div>


<div class="pc" id="program12a">
    <div class="pt">Program 12a</div>
    <div class="p_code">

        <pre><code>#!/bin/bash

            # Read three numbers from the user
            echo "Enter three numbers:"
            read num1
            read num2
            read num3
            
            # Compare the numbers
            if [ "$num1" -gt "$num2" ] && [ "$num1" -gt "$num3" ]; then
                echo "The largest number is $num1"
            elif [ "$num2" -gt "$num1" ] && [ "$num2" -gt "$num3" ]; then
                echo "The largest number is $num2"
            else
                echo "The largest number is $num3"
            fi
            </code></pre>
            <button class="copy-button">Copy</button>

    </div>
</div>
<div class="pc" id="program12b">
    <div class="pt">Program 12b</div>
    <div class="p_code">

        <pre><code>#include <pthread.h>
            #include <semaphore.h>
            #include <stdio.h>
            
            sem_t wrt;
            pthread_mutex_t mutex;
            int cnt = 1;
            int numreader = 0;
            
            void *writer(void *wno)
            {   
                sem_wait(&wrt);
              //sem_wait(&sem_name); If the value of the semaphore is negative, the calling process blocks; 
                cnt = cnt*2;
                printf("Writer %d modified cnt to %d\n",(*((int *)wno)),cnt);
                sem_post(&wrt);
              //sem_post(&sem_name); It increments the value of the semaphore and wakes up a blocked process waiting on the semaphore, if any.
            
            }
            void *reader(void *rno)
            {   
                // Reader acquire the lock before modifying numreader
                pthread_mutex_lock(&mutex);
                numreader++;
                if(numreader == 1) 
                {
                    sem_wait(&wrt); // If this id the first reader, then it will block the writer
                }
                pthread_mutex_unlock(&mutex);
                // Reading Section
                printf("Reader %d: read cnt as %d\n",*((int *)rno),cnt);
            
                // Reader acquire the lock before modifying numreader
                pthread_mutex_lock(&mutex);
                numreader--;
                if(numreader == 0) 
                {
                    sem_post(&wrt); // If this is the last reader, it will wake up the writer.
                }
                pthread_mutex_unlock(&mutex);
            }
            
            int main()
            {   
            
                pthread_t read[3],write[3];
                pthread_mutex_init(&mutex, NULL);
            //initialize a mutex to its default value
                sem_init(&wrt,0,1);
            //sem_init() function initializes an unnamed semaphore and sets its initial value. Syntax: sem_init(sem_t *sem, int pshared, unsigned int value); sem ---> points to a semaphore object to initialize; pshared ---> A value of zero indicates that the semaphore will be used only by threads within the current process. A nonzero value indicates that the semaphore may be used by threads from other processes; value ---> used to initialize the value of the semaphore
                int a[3] = {1,2,3}; //Just used for numbering the reader and writer
            
                for(int i = 0; i < 3; i++) {
                    pthread_create(&read[i], NULL, (void *)reader, (void *)&a[i]);
                  //pthread_create(&tid, &attr, threadfun, args);
                }
                for(int i = 0; i < 3; i++) {
                    pthread_create(&write[i], NULL, (void *)writer, (void *)&a[i]);
                }
            
                for(int i = 0; i < 3; i++) {
                    pthread_join(read[i], NULL);
                }
                for(int i = 0; i < 3; i++) {
                    pthread_join(write[i], NULL);
                }
            
                pthread_mutex_destroy(&mutex);
            //pthread_mutex_destroy() function destroys the mutex object referenced by mutex; 
                sem_destroy(&wrt);
            //int sem_destroy(sem_t *sem)-->destroys the semaphore; no threads should be waiting on the semaphore if its destruction is to succeed.
                return 0;
              }
                
            
            </code></pre>
            <button class="copy-button">Copy</button>

    </div>
</div>


    <script src="./script.js"></script>
</body>
</html>
